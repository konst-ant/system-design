# Ticket Reservation System

## 1. Goals

Design a highly concurrent ticket reservation system capable of handling
massive traffic spikes while ensuring:

-   No double booking of seats
-   Safe payment processing
-   Idempotent client operations
-   Horizontal scalability
-   Strong consistency guarantees for seat ownership

The database is the **single source of truth** for seat ownership and
booking state.

## 2. High-Level Architecture

    Client (generates ClientRequestId)
            ↓
    API Layer (stateless)
            ↓
    Kafka (load buffering, random partitioning)
            ↓
    Worker Fleet (parallel processing)
            ↓
    ACID Database (authority)
            ↓
    Payment Provider
            ↓
    Reconciliation Worker

Key principle:

Kafka provides throughput control.\
Database transactions provide correctness.

## 3. Core Concepts

### 3.1 No Waiting Rooms

Users are never queued in browsers. Requests are accepted immediately
and compete safely via database transactions.

### 3.2 Database as Authority

All seat ownership decisions happen via transactional updates in the
database.

### 3.3 Hold and lazy expiry

Seat lot is reserved with a hold for limited time (5 min) returning user hold_token.  
If user pays withing hold timeout, selected seats become booked, otherwise they return to available pool.
A hold represents a temporary reservation for N seats, all this seats reference one hold_token, payment is executed once for whole hold.

> We introduce hold_token separate from client_request_id (see below) because we want to keep hold expiration separate process, not bound to user request
> Because user request lifecycle is broader, and there is more supportive logic around it e.g. protect for idempotency 

### 3.4 Idempotency

Each booking attempt carries a `clientRequestId` generated by the client  
> clientRequestId essentially need to be generated on client side - browser in case of CSR e.g. `const clientRequestId = crypto.randomUUID();`
> Stored: in JS memory; OR localStorage until completion

Purpose:

-   Prevent double charges
-   Safe retries after network failures
-   Exactly-once logical booking intent


## 4. Data Model (Partial)

### Seats

|Column     |  Description|
|------------| -----------------------------|
|seat_id      |seat identifier|
|show_id      |show|
|status       |AVAILABLE / HELD / BOOKED|
|hold_token   |reservation token|
|version      |optional optimistic version|

### Booking Intent

| Column            |Description|
|-------------------|-------------------------|
| booking_id        |internal id|
| client_request_id |idempotency key|
| status            |PENDING / PAID / FAILED|
| expires_at        |hold expiration|
| response_payload  |client responsse saved|

Unique constraint:

    UNIQUE(client_request_id)


## 5. Request Flow

### Step 1 --- Client Creates Request

Client generates clientRequestId, sent with every retry.


### Step 2 --- API Accepts Request

API validates request and publishes booking command to Kafka.

Partition key:\
  hash(clientRequestId)


### Step 3 --- Worker process request for Holding

Workers consume messages in parallel.

Transaction:

``` sql
BEGIN;

UPDATE seats
SET status='HELD',
    hold_token=:token
WHERE show_id=:show
  AND seat_id IN (...)
  AND status='AVAILABLE';

-- verify row count

COMMIT;
```

Worker service snippet (alternative iterate by one seat):

```
@Transactional
public HoldResult holdSeats(HoldCommand cmd) {
    for (SeatId seat : cmd.seats()) {
        int updated = repo.tryHold(cmd.show, seat, cmd.token());
        if (updated == 0) {
            throw new SeatUnavailableException();
        }
    }
}
```

If affected rows `requested seats` > seat unavailable - return error reservation was not successful to the client.


### Step 4 --- Worker process request for Payment (separate request from client side)

User pays using hold_token.

Create booking intent before running payment

``` sql
INSERT into booking_intent (
    booking_id,
    client_request_id,
    status,
    expires_at
)
VALUES (
    1001,
    'req-8f3c2a91',
    'PENDING',
    '2026-02-21 18:30:00'
);
```

Make payment passing booking_id to payment gateway for reference.

Update seat status and booking_intent status (BOOKED if success, AVAILABLE otherwise)
``` sql
BEGIN;

UPDATE seats
SET status='BOOKED',
WHERE hold_token=:token;

UPDATE booking_intent
SET status='PAID',
WHERE booking_id=:id;

COMMIT;
```


## 6. Concurrency Model

### Database Guarantees

-   Row-level locking
-   Default isolation (READ COMMITTED sufficient)
-   Atomic seats acquisition

Only conflicting seats serialize, we keep DB without contention, scalable

### Deadlock Handling

As requests allowed for multiple seats, there can be deadlocks with reservation if two independent request have seat ranges crossing (remember we reserving in seats table with one SQL holding list of seats). If deadlock occurs:

1.  Transaction rolls back automatically, while consumer in service layer gets `DeadlockDetectedException`, whilst the racing transaction would succeed. We differentiate this situation from reservation conflict (when seats table UPDATE returns 0) by DeadlockDetectedException.
2.  Retry with a jitter. Here we step into normal flow from above, and in case of conflict (most likely as racing consumer has win before) client gets error back

> Deadlock recovery is infrastructure-level and invisible to users


## 7. Payment Flow (Correct Atomicity Model)

### Step 1 --- Create Booking Intent (DB)

Transaction creates booking_intent DB record BEFORE payment, in status PENDING

### Step 2 --- Call Payment Provider

Payment request includes booking_id from booking_intent

### Step 3 --- Payment Success

Worker change booking_intent status as PAID.

### Step 4 --- Failure Recovery

A reconciliation job periodically:

-   scans PENDING booking_intent(s)
-   queries payment provider for reconciliation
-   finalizes inconsistent states: if payment provider said it was paid > changes status PAID, otherwise FAILED

This resolves crashes between payment and DB update, ensures no double charge.

## 8. Kafka Usage

Kafka is used only for:

-   Burst absorption
-   Backpressure
-   Horizontal scaling

Not used for ordering or fairness.

We do requests distribution across Kafka partitions "randomly" with hash(clientRequestId), not bound to showId or other busisness key.  
This provides uniformity of requests distribution per partition. In case of spikes Kafka becomes a shock absorber.    
For example, 100 000 user requests come simultaneously - Kafka with 100 partitions, and 100 consumers - even distribution 1000 requests per partition.  
DB is not overloaded, no DB connection pool exhausted - 100 simulteniously running service workers.

## 9. Handling Lost Responses

Scenario:

1.  Payment succeeds
2.  API response lost
3.  Client retries with same `clientRequestId`

Server detects existing intent and returns previous response_payload from booking_intent.  

No double charge occurs.


## 10. Expiration of Holds

Background job releases expired holds:

``` sql
UPDATE seats
SET status='AVAILABLE',
    hold_token=NULL
WHERE expires_at < NOW();
```

Seats immediately re-enter available pool.


## 11. Scaling Strategy

### Horizontal Scaling

-   Stateless API nodes
-   Kafka partitions scaled independently
-   Worker fleet autoscaling
-   Database read replicas for queries

### Hot Show Behavior

Parallelism achieved by:

-   random Kafka partitioning
-   database row-level locking

Only conflicting seats serialize.


## 12. Failure Handling Summary

  Failure                     |Handling
  --------------------------- |--------------------
  Client retry                |idempotency key
  Worker crash                |Kafka replay
  DB deadlock                 |retry with jitter
  Payment success but crash   |reconciliation job
  Lost response               |idempotent lookup


## 13. Key Design Principles

1.  Minimum coordination required for correctness.
2.  Database enforces ownership.
3.  Idempotency defines user intent.
4.  Recovery over atomic cross-system transactions.
5.  Double booking, lost updates -  Impossible
6.  Double charge  -  Prevented + reconciled
7.  Massive spikes absorbed
8.  Scalability - Horizontal
